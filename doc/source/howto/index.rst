.. |module| replace:: hololinked
 
.. |module-highlighted| replace:: ``hololinked``

.. |br| raw:: html

    <br />

.. toctree::
    :hidden:
    :maxdepth: 2
    
    Expose Python Classes <self>
    clients
    properties/index

    
Expose Python Classes
=====================

Normally, the device is interfaced with a computer through serial, Ethernet etc. or any OS supported hardware protocol, 
& one would write a class to encapsulate the instrumentation properties & commands. Exposing this class to other processes 
and/or to the network, provides access to the hardware for multiple use cases in a client-server model. Such remotely visible 
Python objects are to be made by subclassing from ``Thing``: 

.. literalinclude:: code/thing_inheritance.py
    :language: python
    :linenos:

``instance_name`` is a unique name recognising the instantiated object. It allows multiple 
instruments of same type to be connected to the same computer without overlapping the exposed interface and is therefore a 
mandatory argument to be supplied to the ``Thing`` parent. When maintained unique within the network, it allows 
identification of the hardware itself. Non-experts may use strings composed of 
characters, numbers, dashes and forward slashes, which looks like part of a browser URL, but the general definition is 
that ``instance_name`` should be a URI compatible string.

.. literalinclude:: code/thing_with_http_server.py
    :language: python
    :linenos:
    :lines: 96-99

For attributes (like serial number above), if one requires them to be exposed, one should 
use "properties" defined in ``hololinked.server.properties`` to "type define" the attributes of the object (in a python sense): 

.. literalinclude:: code/thing_with_http_server.py
    :language: python
    :linenos:
    :lines: 2-3, 7-20

Only properties defined in ``hololinked.server.properties`` or subclass of ``Property`` object (note the captial 'P') 
can be exposed to the network, not normal python attributes or python's own ``property``. For HTTP access, specify the 
``URL_path`` and a HTTP request methods for read-write-delete operations, if necessary. This can also be autogenerated if unspecified. 
For non-HTTP remote access (through ZMQ), a predefined client is able to use the object name of the property.

For methods to be exposed on the network, one can use the ``action`` decorator: 

.. literalinclude:: code/thing_with_http_server.py
    :language: python
    :linenos:
    :lines: 2-3, 7-20, 26-33

Arbitrary signature is permitted. Arguments are loosely typed and may need to be constrained with a schema, based 
on the robustness the developer is expecting in their application. However, a schema is optional and it only matters that 
the method signature is matching when requested from a client. Again, specify the ``URL_path`` and HTTP request method 
or leave them out according to the application needs. 

To start a HTTP server for the ``Thing``, one can call the ``run_with_http_server()`` method after instantiating the 
``Thing``. The supplied ``URL_path`` and HTTP request methods to the properties and actions are used by this HTTP server: 

.. literalinclude:: code/thing_with_http_server.py
    :language: python
    :linenos:
    :lines: 96-100


By default, this starts a server a HTTP server and an INPROC zmq socket for the HTTP server to direct the requests 
to the ``Thing`` object. This is a GIL constrained intra-process communication between the HTTP server and ZMQ socket 
as far as python is concerned. All requests are queued normally by this zmq socket as the domain of operation 
under the hood is remote procedure calls (RPC). Therefore, despite the number of requests made to the ``Thing``, only 
one is executed at a time as the hardware normally responds to only one operation at a time. This can be overcome on 
need basis manually through threading or async methods. 

To overload the get-set of properties to directly apply property values onto devices, one may do 
the following:

.. literalinclude:: code/thing_with_http_server_2.py
    :language: python
    :linenos: 
    :lines: 5-25

In non expert terms, when a custom get-set method is not provided, properties look like class attributes however their 
data containers are instantiated at object instance level by default. For example, the ``serial_number`` property defined 
previously as ``String``, whenever set/written, will be complied to a string and assigned as an attribute to each instance 
of the ``OceanOpticsSpectrometer`` class. This is done with an internally generated name. It is not necessary to know this 
internally generated name as the property value can be accessed again in any python logic, say,
|br|
``self.device = Spectrometer.from_serial_number(self.serial_number)`` 
|br|


However, to avoid generating such an internal data container and instead apply the value on the device, one may supply 
custom get-set methods using the fget and fset argument. This is generally useful as the hardware is a better source 
of truth about the value of a property. Further, the write value of a property may not always correspond to a read 
value due to hardware limitations, say, a linear stage could not move to the requested position due to obstacles. 

Events are to be used to asynchronously push data to clients. One can store captured data in properties & supply clients 
with the measured data using events:

.. literalinclude:: code/thing_with_http_server.py 
    :language: python   
    :linenos:
    :lines: 2-3, 5-20, 23-25, 66-85

Events can be defined as class or instance attributes and will be tunnelled as HTTP server sent events. Data may also be 
polled by the client repeatedly but events save network time. 

As previously stated, if one is not interested or not knowledgable to write a HTTP interface, one may drop the URL paths 
and HTTP methods altogether. In this case, the URL paths and HTTP methods will be autogenerated. 

.. literalinclude:: code/thing_with_http_server.py 
    :language: python   
    :linenos:
    :lines: 1-2, 7-12, 35-37, 86-94
   
Further, as it will be clear from :doc:`next <clients>` section, it is also not necessary to use HTTP, although it is 
suggested to use it especially for network exposed objects because its a standarised protocol. Objects locally exposed 
only to other processes within the same computer may stick to ZMQ transport and avoid HTTP altogether if web development 
is not necessary.

It can be summarized that the three main building blocks of a network exposed object, or a hardware ``Thing`` are:

* properties - use them to model settings of instrumentation (both hardware and software-only),
  expose general class/instance attributes, captured & computed data
* actions - use them to issue commands to instruments like start and stop acquisition, connect/disconnect etc.
* events - push measured data, create alerts/alarms, inform availability of certain type of data etc.

Each are separately discussed in depth in their respective sections within the doc found on the section navigation.

